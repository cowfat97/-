
# HashMap线程安全吗？

HashMap 是非线程安全的

## HashMap数据结构

   在线程安全的问题前,先看一下HashMap的数据结构

HashMap 是 Java 中的一个核心类，它基于哈希表（Hash Table）实现，提供了存储键值对（key-value pair）的功能。HashMap 的数据结构非常独特，它结合了数组和链表（在 JDK 1.8 及以后版本中，还结合了红黑树）的特性，以实现高效的查找、插入和删除操作。下面我们将详细解析 HashMap 的数据结构：

### 1. 哈希表（Hash Table）

哈希表是一种根据关键码值（Key）而直接进行访问的数据结构。它通过计算哈希函数得到关键码的哈希地址，并在存储时通过这个地址进行存取。理想情况下，哈希函数能够将不同的关键码映射到不同的地址上，从而避免冲突。然而，在实际应用中，由于哈希函数的局限性和关键码分布的不均匀性，冲突是不可避免的。

### 2. 数组

HashMap 的主干是一个 Node 数组。每个 Node 对象包含一个 key-value 键值对。当我们要存储一个键值对时，首先会计算 key 的哈希值，然后通过这个哈希值确定该键值对在数组中的位置。这个过程类似于通过索引查找数组元素，因此具有非常高的效率（时间复杂度为 O(1)）。

### 3. 链表

当两个不同的 key 计算出的哈希值相同时（即发生了哈希冲突），HashMap 会采用链表的方式来解决这个问题。具体来说，它会在数组的每个位置上维护一个链表，链表中的每个节点都存储了一个键值对。当发生哈希冲突时，新的键值对会被添加到对应位置的链表的末尾。

### 4. 红黑树（JDK 1.8 及以后版本）

在 JDK 1.8 及以后的版本中，HashMap 对数据结构进行了优化。当某个位置的链表长度超过一定阈值（默认为 8）时，HashMap 会将这个链表转换为红黑树来存储。红黑树是一种自平衡的二叉搜索树，它能够在动态插入和删除操作中保持相对平衡的状态，从而提供高效的查找性能。当树的大小小于一定阈值（默认为 6）时，又会退化为链表。这种优化使得 HashMap 在处理大量数据时能够保持较高的性能。

### 5. 动态扩展

当 HashMap 中的元素数量达到阈值（默认为数组长度的 0.75）时，HashMap 会进行动态扩展，即创建一个新的、容量更大的数组，并将原数组中的元素重新哈希到新数组中。这个过程虽然需要一定的时间开销，但它能够确保 HashMap 在处理大量数据时仍然保持较高的性能。

### 总结

HashMap 的数据结构结合了数组、链表和红黑树的特性，实现了高效的查找、插入和删除操作。它通过计算key的哈希值来确定键值对在数组中的位置，并通过链表和红黑树来解决哈希冲突。同时，HashMap 还支持动态扩展，以适应不同规模的数据处理需求。这些特性使得 HashMap 成为Java 中最常用的数据结构之一。

## 线程安全

线程安全是多线程编程中的一个重要概念，它主要关注在多线程环境中，多个线程同时访问共享数据时，如何保证数据的一致性和正确性。

HashMap在多线程情况下无法保证数据安全的：

- put 操作
  当两个线程A和B同时执行put操作时，如果它们计算出的hashCode值相同，并且指向了数组中的同一个位置，那么就会存在数据覆盖的风险。假设线程A先执行put操作，将键值对写入HashMap，然后线程B也执行put操作，写入相同的hashCode对应的数组位置。由于HashMap并没有对这个过程进行同步处理，线程B的写入可能会覆盖线程A已经写入的数据，导致数据丢失或错误。
- 扩容操作
  在多线程环境下，如果两个线程同时触发扩容操作，可能会导致数据不一致或其他问题。

  HashMap的动态扩容过程是当HashMap中的元素数量超过当前容量的负载因子时触发的。这个过程涉及到创建一个新的数组，然后将原有数组中的元素重新分配到新数组中。以下是对HashMap 动态扩容过程的详细解释：

  触发条件：

  HashMap 的动态扩容过程在以下情况下触发：

  当 HashMap 中的元素数量（size）超过了当前数组容量（capacity）与负载因子（load factor）的乘积时。默认的负载因子为 0.75，这意味着当 HashMap 的填充率达到 75% 时，就会触发扩容。
  扩容步骤：

  - 计算新容量：首先，根据当前数组的容量，计算新的数组容量。通常，新的容量会是当前容量的两倍。例如，如果当前容量为 16，则新容量会是 32。
  - 创建新数组：然后，HashMap 会创建一个新的 Node 数组，长度为计算出的新容量。
  - 重新计算哈希值并重新分配元素：接下来，HashMap 会遍历原数组中的每个元素，对每个元素重新计算哈希值，并根据新的哈希值将其放置到新数组中的适当位置。这个过程涉及到对每个元素进行哈希计算，并确定其在新数组中的索引位置。
  - 处理哈希冲突：如果在重新分配元素的过程中出现哈希冲突（即两个或多个元素的哈希值相同），HashMap 会采用链表或红黑树（在 JDK 1.8 及以后版本中）来解决冲突。具体来说，它会将具有相同哈希值的元素添加到同一个链表或红黑树中。

  扩容的时机并非精确地在元素数量达到容量与负载因子乘积的那一刻进行，而是会在某个操作（如 put 或 get）触发时检查是否需要扩容。因此，实际扩容的时间点可能稍晚于理论上的扩容点。而且，在重新计算哈希值并重新分配元素过程中仅会保留一个触发扩容的线程数据，造成数据的丢失。

## 多线程情况HashMap

在多线程环境下，如果需要使用HashMap，可以考虑使用线程安全的HashMap实现，如ConcurrentHashMap或Hashtable。

### ConcurrentHashMap和Hashtable的区别

- ConcurrentHashMap
  ConcurrentHashMap的线程安全机制主要依赖于其内部实现的复杂结构和同步机制。以下是关于ConcurrentHashMap线程安全机制的详细解释：

  在JDK 1.7中，ConcurrentHashMap的线程安全主要通过分段锁（Segment）实现。它将整个哈希表分为多个段，每个段由一个独立的锁来保护。这种设计使得不同线程可以同时访问不同的段，从而提高了并发性能。每个Segment内部包含一个HashEntry数组，用于存储键值对。当对HashEntry元素进行修改时，必须先获得对应的Segment的分段锁。这种分段锁的策略有效地减少了锁的竞争，提高了并发访问的效率。

  而在JDK 1.8中，ConcurrentHashMap的线程安全机制进行了优化。它放弃了分段锁的设计，转而采用CAS（Compare and Swap）操作和synchronized关键字来实现线程安全。CAS操作是一种无锁技术，它可以在多线程环境下实现无锁的数据修改。当多个线程尝试修改同一个数据时，CAS操作会通过比较当前值和预期值来确保数据的一致性。如果当前值与预期值相同，则进行数据的修改；否则，说明有其他线程已经修改过该数据，此时需要重新读取数据并再次尝试修改。这种机制避免了锁的使用，减少了线程间的等待和阻塞，从而提高了并发性能。

  此外，在JDK 1.8中，ConcurrentHashMap还在扩容方面进行了优化。当哈希表需要扩容时，它会创建一个新的哈希表，并将原有哈希表中的数据逐个迁移到新表中。这个过程中，为了保证线程安全，ConcurrentHashMap采用了分步迁移的策略。它先迁移一部分数据到新表，然后让新表和旧表一起提供读写服务。当旧表中的数据全部迁移完毕后，再切换到新表提供服务。这种分步迁移的策略避免了在扩容过程中的锁竞争和数据不一致问题。

  总的来说，ConcurrentHashMap通过分段锁、CAS操作和synchronized关键字等机制实现了线程安全，并在JDK 1.8中进行了优化，提高了并发性能和扩容效率。这使得它在高并发场景下能够保持较好的性能和数据一致性。
- Hashtable
  Hashtable的线程安全机制主要依赖于其内部的同步控制。Hashtable的每个public方法，无论是读取还是写入操作，都被声明为synchronized，这意味着在任何时刻，只有一个线程能够执行Hashtable的某个public方法。这种设计确保了Hashtable在多线程环境下的线程安全性。

  具体来说，当多个线程尝试同时访问或修改Hashtable中的数据时，Java的虚拟机（JVM）会负责实现线程之间的同步。当一个线程进入Hashtable的某个public方法时，它会获取Hashtable对象的内部锁。其他尝试进入Hashtable的其他public方法的线程将被阻塞，直到第一个线程释放锁。这样，就确保了同一时刻只有一个线程能够访问或修改Hashtable中的数据，从而避免了数据不一致的问题。

  然而，这种线程安全机制也带来了一定的性能开销。由于每个public方法都被同步，这意味着即使只是进行简单的读取操作，也需要获取锁并等待其他线程释放锁。在高并发场景下，这种同步控制可能会导致性能瓶颈。

  因此，虽然Hashtable是线程安全的，但在需要高并发性能的场景下，开发者可能会选择使用其他并发容器，如ConcurrentHashMap。ConcurrentHashMap通过更精细化的同步控制和分段锁机制，实现了更高的并发性能，同时保持了线程安全性。

  总结来说，Hashtable的线程安全机制主要依赖于其每个public方法的同步控制，确保了同一时刻只有一个线程能够访问或修改Hashtable中的数据。然而，这种机制在高并发场景下可能会导致性能问题，因此开发者在选择线程安全的集合类时需要综合考虑性能和安全性。

ConcurrentHashMap相对于Hashtable来说，采用了分段锁的机制，将hash表分为多个桶，每个桶都有自己的锁，从而提高了并发性能。而Hashtable则对所有CRUD操作都进行了线程同步，因此效率相对较低。

另外，还需要注意线程安全容器的使用方式。例如，Vector和CopyOnWriteArrayList也是线程安全的容器，但它们的使用方式和HashMap有所不同。Vector的每个方法都进行了同步，因此在多线程环境下可以直接使用，但效率较低。而CopyOnWriteArrayList则采用了写时复制的机制，只有在修改时才会复制一个新的数组，从而保证了读操作的线程安全性，但写操作的开销较大。

总之，HashMap是非线程安全的，需要在多线程环境下使用时考虑线程安全问题，选择合适的线程安全容器和实现方式。
