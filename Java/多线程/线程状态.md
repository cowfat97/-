# 线程状态

[TOC]

## 线程

### 线程与进程

从操作系统角度看，线程和进程是系统中两个重要的概念，它们在程序的执行和资源管理中起着关键的作用。下面将详细解释线程与进程之间的关系：

1. 根本区别：
  * 进程是资源分配的最小单位。当启动一个进程时，操作系统会为其分配内存，并建立相应的数据表来维护其代码段、堆栈段和数据段。进程拥有自己独立的地址空间。
  * 线程是资源调度（特别是CPU）的最小单位。它是进程中的一个执行单元，多个线程可以共享同一个进程的资源。线程并不拥有独立的地址空间，而是使用其所属进程的地址空间。
2. 资源共享与开销：
  * 线程之间共享进程的数据段，因此它们在访问共享资源时更加高效，但同时也需要处理同步和互斥的问题，以避免数据的不一致性。
  * 由于线程共享进程的地址空间和其他资源，所以创建一个新线程的开销要比创建一个新进程小得多。这是因为创建新进程时，需要为其分配独立的内存空间和资源，而创建线程则只需要在现有进程中为其分配一些必要的资源即可。
3. 通信与同步：
  * 线程间通信相对简单，因为它们共享进程的内存空间，可以直接读写共享数据。但为了避免竞态条件，需要使用同步机制，如互斥锁、条件变量等。
  * 进程间通信则更为复杂，因为它们拥有独立的内存空间。常见的进程间通信方式包括管道、消息队列、信号量、共享内存等。这些机制需要在操作系统层面进行支持和管理。
4. 健壮性与拓展性：
  * 多进程编程通常比多线程编程更健壮。因为如果一个线程崩溃，可能会导致整个进程崩溃，从而影响到其他线程的执行。而多进程编程中，由于每个进程都有独立的地址空间，一个进程的崩溃不会影响其他进程的执行。
  * 在拓展性方面，进程适合扩展到多机环境，而线程适合拓展到多核处理器。这是因为多机环境中，每台机器都有自己的内存空间和资源，适合通过进程进行隔离和管理；而在多核处理器中，所有核心共享同一块内存空间，通过线程可以更好地利用多核并行处理的能力。

总的来说，线程和进程在操作系统中各有其特点和用途。它们在并发执行、资源管理和通信同步等方面有着密切的联系和差异。选择使用线程还是进程取决于具体的应用场景和需求。

## CPU 分片机制

CPU 对于进程或线程都是非常重要的资源，在多进程多线程情况怎么样能合理的分配 CPU 资源？CPU分片机制

CPU分片机制，也称为时间分片或轮转调度，是操作系统用来管理和分配CPU时间的策略。在这种机制下，操作系统将CPU的执行时间分割成固定或可变长度的时间片，每个进程或线程获得一个时间片来执行其任务。当时间片用完时，操作系统会暂停当前进程或线程的执行，并将其状态信息保存起来，然后选择下一个进程或线程来执行。这样，多个进程或线程可以在一段时间内交替执行，从而实现了并发执行的效果。

## 线程生命周期

了解了线程在操作系统中的各种相关概念，现在来看一下线程的生命周期

在单线程理想情况下 线程是这样执行的：

- 线程被创建后，处于**新建（NEW）**状态。
- 当调用线程的start()方法后，线程从**新建（NEW）状态进入就绪（RUNNABLE）**状态。
- 线程获得CPU时间片后，从**就绪（RUNNABLE）状态变为正在执行。注意正在执行并不是一个独立的状态，它仍然是就绪（RUNNABLE）**状态的一部分。
- 当线程的run()方法执行完毕，或者线程被异常终止时，线程从**就绪（RUNNABLE）状态变为终止（TERMINATED）状态。一旦线程进入终止（TERMINATED）**状态，就不能再回到其他状态。

但实际会有很多造成阻塞的情况：
- 阻塞
  1. 同步阻塞
    当线程试图获取一个内部的对象锁（也称为监视器锁或同步锁），但该锁正被其他线程持有时，线程会进入同步阻塞状态。这是Java中基本的线程同步机制，用于协调多个线程对共享资源的访问。
    同步阻塞通常发生在synchronized块或方法上。当一个线程进入synchronized块时，它需要获取该块所属对象的锁。如果锁已经被其他线程持有，则当前线程会被阻塞，直到锁被释放。
  2. I/O阻塞（Blocked on I/O）：
    线程在执行过程中可能会进行I/O操作，如读取文件、网络通信等。当这些I/O操作不能立即完成时（例如，等待网络响应或磁盘读写），线程会进入I/O阻塞状态。
    在I/O阻塞状态下，线程会等待I/O操作完成。一旦I/O操作完成或发生异常，线程通常会从阻塞状态返回到就绪状态，并继续执行后续的代码。
- 等待
  1. 等待阻塞
    当线程调用某些方法（如Object.wait()、Thread.join()或LockSupport.park()）时，它会进入等待状态。这些方法通常会让线程等待某个条件成立或另一个线程完成某项操作。
    在等待状态下，线程不会占用CPU资源，而是会释放其持有的锁（如果有的话）并进入等待队列。只有当其他线程执行了特定的动作（如通知或中断）后，等待的线程才有可能被唤醒并重新进入就绪状态。
- 超时等待
  1. 其他阻塞情况：
    除了上述几种常见的阻塞情况外，线程还可能因为其他原因进入阻塞状态。例如，线程可能调用Thread.sleep(long)方法使自身休眠一段时间，在这段时间内线程会进入阻塞状态。
    另外，当线程使用某些高级并发工具（如Semaphore、CountDownLatch、CyclicBarrier等）时，也可能会因为等待这些工具的状态改变而进入阻塞状态。

线程的阻塞状态并不是一种永久性的状态。一旦导致阻塞的原因消失或满足了一定的条件（如获得了锁、I/O操作完成、等待时间超时等），线程就会从阻塞状态返回到就绪状态，并有机会再次被线程调度器选中以继续执行。因此，在设计和编写多线程程序时，合理处理线程的阻塞状态对于确保程序的正确性和性能至关重要。